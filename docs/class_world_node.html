<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Runaway Monkey: WorldNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Runaway Monkey
   &#160;<span id="projectnumber">0.3</span>
   </div>
   <div id="projectbrief">Top-Down shooter coded with C++ using SFML.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_world_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">WorldNode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A world node is anything that exists and should be updated in the world.  
 <a href="class_world_node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="world__node_8h_source.html">world_node.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for WorldNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_world_node.png" usemap="#WorldNode_map" alt=""/>
  <map id="WorldNode_map" name="WorldNode_map">
<area href="class_entity.html" title="WorldNode that has a presence and can move around. " alt="Entity" shape="rect" coords="154,112,247,136"/>
<area href="class_sound_node.html" title="Node that can play sound effects using a SoundPlayer. " alt="SoundNode" shape="rect" coords="257,112,350,136"/>
<area href="class_sprite_node.html" title="Node with a sprite that doesn&#39;t interact with the world. " alt="SpriteNode" shape="rect" coords="360,112,453,136"/>
<area href="class_text_node.html" title="Node with some text that doesn&#39;t interact with the world. " alt="TextNode" shape="rect" coords="463,112,556,136"/>
<area href="class_actor.html" title="An Entity that is &quot;alive&quot; and interact with the world. " alt="Actor" shape="rect" coords="0,168,93,192"/>
<area href="class_crosshair.html" title="Entity to handle where the player is targeting in the window. " alt="Crosshair" shape="rect" coords="103,168,196,192"/>
<area href="class_pickup.html" title="Manages objects that can be picked up by the player and its effects. " alt="Pickup" shape="rect" coords="206,168,299,192"/>
<area href="class_projectile.html" title="Entity with a fixed lifetime that moves at constant velocity. " alt="Projectile" shape="rect" coords="309,168,402,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9fc48d1df0038b1d3a20443ad611f475"><td class="memItemLeft" align="right" valign="top">typedef std::unique_ptr&lt; <a class="el" href="class_world_node.html">WorldNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#a9fc48d1df0038b1d3a20443ad611f475">Ptr</a></td></tr>
<tr class="separator:a9fc48d1df0038b1d3a20443ad611f475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef2fcd093c447fa502c7c233a3772e2"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="class_world_node.html">WorldNode</a> *, <a class="el" href="class_world_node.html">WorldNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#a2ef2fcd093c447fa502c7c233a3772e2">Pair</a></td></tr>
<tr class="separator:a2ef2fcd093c447fa502c7c233a3772e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6726b7588534911686b6e8e4bc111487"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#a6726b7588534911686b6e8e4bc111487">WorldNode</a> ()</td></tr>
<tr class="separator:a6726b7588534911686b6e8e4bc111487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c631602987076ba14d1739763eee0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#a85c631602987076ba14d1739763eee0c">attachChild</a> (<a class="el" href="class_world_node.html#a9fc48d1df0038b1d3a20443ad611f475">Ptr</a> child)</td></tr>
<tr class="memdesc:a85c631602987076ba14d1739763eee0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a node to the calling node as a child.  <a href="#a85c631602987076ba14d1739763eee0c">More...</a><br /></td></tr>
<tr class="separator:a85c631602987076ba14d1739763eee0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756447281cffed385dae95a753c8c19e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_world_node.html#a9fc48d1df0038b1d3a20443ad611f475">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#a756447281cffed385dae95a753c8c19e">detachChild</a> (const <a class="el" href="class_world_node.html">WorldNode</a> &amp;node)</td></tr>
<tr class="memdesc:a756447281cffed385dae95a753c8c19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches a child node from the calling node.  <a href="#a756447281cffed385dae95a753c8c19e">More...</a><br /></td></tr>
<tr class="separator:a756447281cffed385dae95a753c8c19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0c20fe4e5dde9ce1ada846e450aa2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#a1b0c20fe4e5dde9ce1ada846e450aa2e">update</a> (sf::Time)</td></tr>
<tr class="memdesc:a1b0c20fe4e5dde9ce1ada846e450aa2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node and then recursively updates its children.  <a href="#a1b0c20fe4e5dde9ce1ada846e450aa2e">More...</a><br /></td></tr>
<tr class="separator:a1b0c20fe4e5dde9ce1ada846e450aa2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7316be11eacc30829d9a5a203078f05d"><td class="memItemLeft" align="right" valign="top">sf::Vector2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#a7316be11eacc30829d9a5a203078f05d">getWorldPosition</a> () const</td></tr>
<tr class="separator:a7316be11eacc30829d9a5a203078f05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4650485b32bfd9d12d087640d521b14"><td class="memItemLeft" align="right" valign="top">sf::Transform&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#ac4650485b32bfd9d12d087640d521b14">getWorldTransform</a> () const</td></tr>
<tr class="separator:ac4650485b32bfd9d12d087640d521b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963c14fed070df6558d39a628bf5909a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_category.html#a2ff936dbd42aeae91fdfb6f8456a8ab0">Category::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#a963c14fed070df6558d39a628bf5909a">getCategory</a> () const</td></tr>
<tr class="separator:a963c14fed070df6558d39a628bf5909a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113dcc3aaa51639dc878d84363fbe569"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#a113dcc3aaa51639dc878d84363fbe569">setRoot</a> ()</td></tr>
<tr class="memdesc:a113dcc3aaa51639dc878d84363fbe569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the node to be a root node.  <a href="#a113dcc3aaa51639dc878d84363fbe569">More...</a><br /></td></tr>
<tr class="separator:a113dcc3aaa51639dc878d84363fbe569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13467e27e81acb1138a01799c0f1e9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#ae13467e27e81acb1138a01799c0f1e9b">onCommand</a> (const <a class="el" href="struct_command.html">Command</a> &amp;, sf::Time)</td></tr>
<tr class="memdesc:ae13467e27e81acb1138a01799c0f1e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reacts to a command and sends it to its children too.  <a href="#ae13467e27e81acb1138a01799c0f1e9b">More...</a><br /></td></tr>
<tr class="separator:ae13467e27e81acb1138a01799c0f1e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fabeb478ae389cfe2a093e111eb39a"><td class="memItemLeft" align="right" valign="top">virtual sf::FloatRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#a44fabeb478ae389cfe2a093e111eb39a">getHitbox</a> () const</td></tr>
<tr class="separator:a44fabeb478ae389cfe2a093e111eb39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50efea26b0edb2038ddc4e375d553c7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#a50efea26b0edb2038ddc4e375d553c7e">checkNodeCollision</a> (<a class="el" href="class_world_node.html">WorldNode</a> &amp;node, std::set&lt; <a class="el" href="class_world_node.html#a2ef2fcd093c447fa502c7c233a3772e2">Pair</a> &gt; &amp;collisionPairs)</td></tr>
<tr class="separator:a50efea26b0edb2038ddc4e375d553c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ca5c09988ca082d5970777e0229fc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#ac1ca5c09988ca082d5970777e0229fc6">checkWorldCollision</a> (<a class="el" href="class_world_node.html">WorldNode</a> &amp;root, std::set&lt; <a class="el" href="class_world_node.html#a2ef2fcd093c447fa502c7c233a3772e2">Pair</a> &gt; &amp;collisionPairs)</td></tr>
<tr class="separator:ac1ca5c09988ca082d5970777e0229fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac889298c50cf6114ce0184735db4e21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#aac889298c50cf6114ce0184735db4e21">isMarkedForRemoval</a> () const</td></tr>
<tr class="separator:aac889298c50cf6114ce0184735db4e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee4306bfcf9721df1afee7fd457bbf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#adee4306bfcf9721df1afee7fd457bbf4">destroy</a> ()</td></tr>
<tr class="separator:adee4306bfcf9721df1afee7fd457bbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f79cc57ae9b58550c73bd63074ebe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_world_node.html#a01f79cc57ae9b58550c73bd63074ebe7">cleanUp</a> ()</td></tr>
<tr class="memdesc:a01f79cc57ae9b58550c73bd63074ebe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively remove children that are marked for removal.  <a href="#a01f79cc57ae9b58550c73bd63074ebe7">More...</a><br /></td></tr>
<tr class="separator:a01f79cc57ae9b58550c73bd63074ebe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A world node is anything that exists and should be updated in the world. </p>
<p>A world node (or just node) is something that exists in the world, and is updated and drawn (if it has something to be drawn) each frame. Since it inherits from the sf::Transformable class, it has a position in the world and has methods to change its scale, position or rotation. <br />
 Nodes get attached to others in a tree structure. Each node has a pointer to its parent node (<code>nullptr</code> if the node doesn't have a parent, i.e. it's a root node), and can have several children attached to it using the <a class="el" href="class_world_node.html#a85c631602987076ba14d1739763eee0c" title="Attaches a node to the calling node as a child. ">WorldNode::attachChild</a> method. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2ef2fcd093c447fa502c7c233a3772e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef2fcd093c447fa502c7c233a3772e2">&#9670;&nbsp;</a></span>Pair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="class_world_node.html">WorldNode</a>*, <a class="el" href="class_world_node.html">WorldNode</a>*&gt; <a class="el" href="class_world_node.html#a2ef2fcd093c447fa502c7c233a3772e2">WorldNode::Pair</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fc48d1df0038b1d3a20443ad611f475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc48d1df0038b1d3a20443ad611f475">&#9670;&nbsp;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unique_ptr&lt;<a class="el" href="class_world_node.html">WorldNode</a>&gt; <a class="el" href="class_world_node.html#a9fc48d1df0038b1d3a20443ad611f475">WorldNode::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6726b7588534911686b6e8e4bc111487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6726b7588534911686b6e8e4bc111487">&#9670;&nbsp;</a></span>WorldNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WorldNode::WorldNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default node constructor.</p>
<p>By default, the node doesn't have a parent and doesn't have any children attached to it, but is not a root node unless you call <a class="el" href="class_world_node.html#a113dcc3aaa51639dc878d84363fbe569" title="Sets the node to be a root node. ">WorldNode::setRoot()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a85c631602987076ba14d1739763eee0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c631602987076ba14d1739763eee0c">&#9670;&nbsp;</a></span>attachChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WorldNode::attachChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_world_node.html#a9fc48d1df0038b1d3a20443ad611f475">Ptr</a>&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a node to the calling node as a child. </p>
<p>The method will transfer ownership of the node to the calling node. After the function is called, the passed node's parent will be the calling node, and the calling node will have the passed node as a child.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td><a class="el" href="class_world_node.html#a9fc48d1df0038b1d3a20443ad611f475">WorldNode::Ptr</a> of the node to be attached (passed node). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50efea26b0edb2038ddc4e375d553c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50efea26b0edb2038ddc4e375d553c7e">&#9670;&nbsp;</a></span>checkNodeCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WorldNode::checkNodeCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_world_node.html">WorldNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="class_world_node.html#a2ef2fcd093c447fa502c7c233a3772e2">Pair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>collisionPairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the node is colliding with the passed node (that is, if their hitboxes intersect). If they are colliding, add both nodes as a pair to the collisionPairs set. Then, recursively check its children for collisions with the passed node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Passed node. It's the node to check for collisions with. </td></tr>
    <tr><td class="paramname">collisionPairs</td><td>Reference to a set containing pairs of nodes that collide. It is used for collision logic in World::handleCollisions() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1ca5c09988ca082d5970777e0229fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ca5c09988ca082d5970777e0229fc6">&#9670;&nbsp;</a></span>checkWorldCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WorldNode::checkWorldCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_world_node.html">WorldNode</a> &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="class_world_node.html#a2ef2fcd093c447fa502c7c233a3772e2">Pair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>collisionPairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively checks collisions for all nodes attached to the passed node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Node that contains all the nodes that should be checked for collisions with each other. </td></tr>
    <tr><td class="paramname">collisionPairs</td><td>Reference to a set containing pairs of nodes that collide. It is used for collision logic in World::handleCollisions() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01f79cc57ae9b58550c73bd63074ebe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f79cc57ae9b58550c73bd63074ebe7">&#9670;&nbsp;</a></span>cleanUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WorldNode::cleanUp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively remove children that are marked for removal. </p>
<p>The method will remove any of the calling node's children that is marked for removal (thus detaching them from its parent), and then do the same for the remaining children. After the function finishes, all nodes in the tree below the calling node that were marked for removal will have been removed from the tree.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_world_node.html#adee4306bfcf9721df1afee7fd457bbf4">destroy()</a> </dd></dl>

</div>
</div>
<a id="adee4306bfcf9721df1afee7fd457bbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee4306bfcf9721df1afee7fd457bbf4">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WorldNode::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the node to be removed the next time the cleanup function is called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_world_node.html#a01f79cc57ae9b58550c73bd63074ebe7" title="Recursively remove children that are marked for removal. ">cleanUp()</a> </dd></dl>

</div>
</div>
<a id="a756447281cffed385dae95a753c8c19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756447281cffed385dae95a753c8c19e">&#9670;&nbsp;</a></span>detachChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_world_node.html#a9fc48d1df0038b1d3a20443ad611f475">WorldNode::Ptr</a> WorldNode::detachChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_world_node.html">WorldNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches a child node from the calling node. </p>
<p>After the function is called, the calling node will no longer have the passed node as a child, and the passed node will have no parent. Children of the passed node will not be affected by this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Reference to the node to be detached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The detached node, now without a parent. </dd></dl>

</div>
</div>
<a id="a963c14fed070df6558d39a628bf5909a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963c14fed070df6558d39a628bf5909a">&#9670;&nbsp;</a></span>getCategory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_category.html#a2ff936dbd42aeae91fdfb6f8456a8ab0">Category::Type</a> WorldNode::getCategory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_category.html#a2ff936dbd42aeae91fdfb6f8456a8ab0a0f1f5ed73c8e8a85419a9fd51e83c7c1" title="Category for all nodes that don&#39;t interact with anything with exception of the root node...">Category::SceneRoot</a> if the node is a root node, <a class="el" href="namespace_category.html#a2ff936dbd42aeae91fdfb6f8456a8ab0ae45daecedd1b5f037e9e6e915a44f3b0">Category::Scene</a> otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_world_node.html#a113dcc3aaa51639dc878d84363fbe569" title="Sets the node to be a root node. ">WorldNode::setRoot()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_projectile.html#abfdb3223415fbf098568b66cc94731d2">Projectile</a>, <a class="el" href="class_sprite_node.html#a42c490de1226287701848e24ddddfc8f">SpriteNode</a>, <a class="el" href="class_pickup.html#a65dd45b0f3d8160f12c5645752a4ac64">Pickup</a>, <a class="el" href="class_actor.html#ac827007dedbdfca068ed4fcede1b7e97">Actor</a>, <a class="el" href="class_sound_node.html#ae9dd8f869f36590bfbabe416701c0285">SoundNode</a>, <a class="el" href="class_text_node.html#a486e5e590fdee1793cb84dcc8a8e57d6">TextNode</a>, and <a class="el" href="class_crosshair.html#a69e6a1632f85daf86a6b4e91a41f4804">Crosshair</a>.</p>

</div>
</div>
<a id="a44fabeb478ae389cfe2a093e111eb39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fabeb478ae389cfe2a093e111eb39a">&#9670;&nbsp;</a></span>getHitbox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::FloatRect WorldNode::getHitbox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an empty rectangle. This method is reimplemented in more specific nodes to return the actual hitbox of its sprite.</p>
<dl class="section return"><dt>Returns</dt><dd>An empty rectangle. </dd></dl>

<p>Reimplemented in <a class="el" href="class_entity.html#a1f7498e7cd92503ce445b74ea42862f4">Entity</a>.</p>

</div>
</div>
<a id="a7316be11eacc30829d9a5a203078f05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7316be11eacc30829d9a5a203078f05d">&#9670;&nbsp;</a></span>getWorldPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sf::Vector2f WorldNode::getWorldPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the absolute position in the world, that is, after applying all the transforms relative to its parents up until the root node, that is, until we reach a node without a parent.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector with the absolute position of the node in the world. </dd></dl>

</div>
</div>
<a id="ac4650485b32bfd9d12d087640d521b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4650485b32bfd9d12d087640d521b14">&#9670;&nbsp;</a></span>getWorldTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sf::Transform WorldNode::getWorldTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the resulting transform after applying all the transforms relative to its parents up until the root node, that is, until we reach a node without a parent.</p>
<dl class="section return"><dt>Returns</dt><dd>A transform in the world coordinates. </dd></dl>

</div>
</div>
<a id="aac889298c50cf6114ce0184735db4e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac889298c50cf6114ce0184735db4e21">&#9670;&nbsp;</a></span>isMarkedForRemoval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WorldNode::isMarkedForRemoval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the node has been set to be removed the next time the cleanup function is called, and false otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the node is going to be removed before the next frame, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_world_node.html#adee4306bfcf9721df1afee7fd457bbf4">destroy()</a> </dd>
<dd>
<a class="el" href="class_world_node.html#a01f79cc57ae9b58550c73bd63074ebe7" title="Recursively remove children that are marked for removal. ">cleanUp()</a> </dd></dl>

</div>
</div>
<a id="ae13467e27e81acb1138a01799c0f1e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13467e27e81acb1138a01799c0f1e9b">&#9670;&nbsp;</a></span>onCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WorldNode::onCommand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_command.html">Command</a> &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Time&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reacts to a command and sends it to its children too. </p>
<p>The node checks if the command's category matches its category. If it does, it executes it, otherwise it does nothing. In all cases, it sends the command down to its children, calling their own onCommand methods.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_command.html" title="Commands handle actions in an abstract way. ">Command</a> </dd></dl>

</div>
</div>
<a id="a113dcc3aaa51639dc878d84363fbe569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113dcc3aaa51639dc878d84363fbe569">&#9670;&nbsp;</a></span>setRoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WorldNode::setRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the node to be a root node. </p>
<p>By default, a node is not considered a root node. A node can only become a root node by calling this method. Being or not a root node only affects the node's category (see <a class="el" href="class_world_node.html#a963c14fed070df6558d39a628bf5909a">getCategory()</a>), which affects the logic of the game as some command might need to find the root node (see <a class="el" href="struct_command.html">Command</a>). <b>Important!:</b> Only one node of the node graph should be a root node, which is the node at the top of the tree structure, ultimate parent of all the nodes in play. </p>

</div>
</div>
<a id="a1b0c20fe4e5dde9ce1ada846e450aa2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0c20fe4e5dde9ce1ada846e450aa2e">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WorldNode::update </td>
          <td>(</td>
          <td class="paramtype">sf::Time&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the node and then recursively updates its children. </p>
<p>By default, nothing happens when a node is updated. More specific nodes, however, override the update function for different purposes. See for example <a class="el" href="class_actor.html">Actor</a> or <a class="el" href="class_projectile.html">Projectile</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="world__node_8h_source.html">world_node.h</a></li>
<li>src/<a class="el" href="world__node_8cpp.html">world_node.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
